import fastf1
import pandas as pd
import numpy as np
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt
from scipy.stats import zscore

fastf1.Cache.enable_cache('cache')

std_year_pos_diff = np.std(pos_diffs, ddof=1)
z_scores_all = zscore(pos_diffs)


yearly_data = {}

for year in range(2021, 2025):
    schedule = fastf1.get_event_schedule(year)
    if schedule.empty or 'RoundNumber' not in schedule.columns:
        print(f"⚠️ No valid schedule for {year}, skipping.")
        continue
    pos_diffs = []
    
    for _, row in schedule.iterrows():
        print(f"Processing {year} - Round {row['RoundNumber']} - {row['EventName']}")

        try:
            session = fastf1.get_session(year, row['RoundNumber'], 'R')
            session.load()
        except Exception as e:
            print(f"Failed to load session: {row['EventName']} ({year}) — {e}")
            continue

        try:
            if session.weather_data['Rainfall'].sum() > 0:
                print(f"Rainy session, skipping {row['EventName']} ({year})")
                continue
        except Exception as e:
            print(f"⚠️ Could not get weather data for: {row['EventName']} ({year}) — {e}")
            continue

        for drv in session.drivers:
            laps = session.laps.pick_driver(drv)
            if laps.empty or drv not in session.results.index:
                continue

            result = session.results.loc[drv]
            if result['Status'] != 'Finished':
                continue

            drv_data = yearly_data.setdefault((year, drv), {
                'BrakeCount': 0,
                'TotalLaps': 0,
                'SpeedList': [],
                'RpmList': [],
                'DrsUsage': 0,
                'DrsPossible': 0,
                'PosDiffList': [],
                'Name': session.get_driver(drv)['FullName']
            })

            # เพิ่ม position diff (grid - finish)
            pos_diff = result['GridPosition'] - result['Position']
            drv_data['PosDiffList'].append(pos_diff)
            pos_diffs.append(pos_diff)


        for lap in laps.iterlaps():
                tel = lap[1].get_telemetry()
                braking = tel[(tel['Brake'] == True) & (tel['Throttle'] == 0)]
                drv_data['BrakeCount'] += len(braking)
                drv_data['SpeedList'].extend(tel['Speed'].dropna())
                drv_data['RpmList'].extend(tel['RPM'].dropna())
                drv_data['DrsUsage'] += tel['DRS'].fillna(0).gt(0).sum()
                drv_data['DrsPossible'] += tel['DRS'].notna().sum()
                drv_data['TotalLaps'] += 1

    # คำนวณค่าเฉลี่ยของ pos_diff ทั้งปี แก้เป็นz score
    
    i = 0
    for (yr, drv), data in yearly_data.items():
        if yr == year:
           n = len(data['PosDiffList'])
           data['PosDiffSTD'] = std_year_pos_diff
           data['PosDiffZScores'] = z_scores_all[i:i+n]
           i += n

# --- สร้าง DataFrame ---
records = []
for (year, drv), values in yearly_data.items():
    drs_pct = (values['DrsUsage'] / values['DrsPossible']) * 100 if values['DrsPossible'] > 0 else 0
    records.append({
        'Year': year,
        'Driver': values['Name'],
        'PosDiffZScores': values['PosDiffZScores'],
        'BrakePerCorner': values['BrakeCount'] / values['TotalLaps'] if values['TotalLaps'] else 0,
        'AvgSpeed': np.mean(values['SpeedList']),
        'AvgRPM': np.mean(values['RpmList']),
        'DRSUsagePct': drs_pct
    })


df = pd.DataFrame(records)


#%%
import numpy as np
import pandas as pd
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt

# Define a safe mean function that avoids NaN
def safe_mean(lst):
    return np.mean(lst) if lst else 0

# Use `yearly_data` as the source dictionary for driver data
cluster_data = []
for (year, driver), values in yearly_data.items():
    cluster_data.append({
        'Year': year,
        'Driver': values['Name'],
        'PosDiffZScores': values['PosDiffZScores'],
        'BrakePerCorner': values['BrakeCount'] / values['TotalLaps'] if values['TotalLaps'] else 0,
        'AvgSpeed': safe_mean(values['SpeedList']),
        'AvgRPM': safe_mean(values['RpmList']),
        'DRSUsagePct': values['DrsUsage'] / values['DrsPossible'] * 100 if values['DrsPossible'] > 0 else 0
    })

# Create DataFrame
df = pd.DataFrame(cluster_data)

# Convert PosDiffZScores list to a single representative number (e.g. mean)
df['PosDiffZScores'] = df['PosDiffZScores'].apply(lambda x: np.mean(x) if isinstance(x, list) and x else 0)

# Select features
features = ['PosDiffZScores', 'BrakePerCorner', 'AvgSpeed', 'AvgRPM', 'DRSUsagePct']
X = df[features].apply(pd.to_numeric, errors='coerce')

# Optional: Only keep rows where speed and RPM are non-zero
X = X[(X['AvgSpeed'] > 0) & (X['AvgRPM'] > 0)]

# Drop any remaining NaNs (shouldn't be many after safe_mean)
X = X.dropna()

# Final clean DataFrame
df_clean = df.loc[X.index]

print("✅ Original rows:", len(df))
print("✅ Cleaned rows:", len(df_clean))

# Run KMeans clustering
kmeans = KMeans(n_clusters=4, random_state=42)
df_clean['Cluster'] = kmeans.fit_predict(X)

# Label the clusters (optional)
df_clean['ClusterLabel'] = df_clean['Cluster'].map({
    0: '0',
    1: '1',
    2: '2',
    3: '3'
})

# Visualize (example: AvgSpeed vs. AvgRPM)
plt.figure(figsize=(8, 6))
for label in df_clean['ClusterLabel'].unique():
    subset = df_clean[df_clean['ClusterLabel'] == label]
    plt.scatter(subset['AvgSpeed'], subset['AvgRPM'], label=f'Cluster {label}')

plt.xlabel('Average Speed')
plt.ylabel('Average RPM')
plt.title('KMeans Clusters of Driver Race Behavior')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()
